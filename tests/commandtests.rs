use std::env;
use bluest::Device;
use log::info;
use darkelf::{command::CommandGenerator, model::{DeviceMode, DeviceSettings, Playback}, util};

use std::sync::Once;
static INIT: Once = Once::new();

fn init_logger() {
    INIT.call_once(|| {
        util::setup_logging();
    });
}

#[test]
fn test_check_received_data() {
   
    init_logger();

    // Test data from the log
    let random_data = [0xED, 0x00, 0x05, 0xD5];
    
    // These are the expected values from actual device response
    let expected = [0x88, 0x7F, 0x42, 0x82];
    info!("Expected verification bytes: {:02X?}", expected);
    
    let received_data = "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
    info!("Response verification part: {}", &received_data[received_data.len() - 24..received_data.len() - 16]);
    
    // Print expected verification bytes
    info!("Expected verification bytes: {:02X?}", expected);
    
    // Get verification part from response (8 bytes)
    let response_verify = &received_data[received_data.len() - 24..received_data.len() - 16];
    info!("Response verification part: {}", response_verify);
    
    // Parse received verification bytes
    let mut received = Vec::with_capacity(4);
    for i in 0..4 {
        let hex_pair = &response_verify[i*2..i*2+2];
        let value = u8::from_str_radix(hex_pair, 16).unwrap();
        received.push(value);
    }
    info!("Received verification bytes: {:02X?}", received);
    
    // Execute the verification
    let (success, device_info) = CommandGenerator::check_received_data(received_data, &random_data);
    
    // Verify the results
    assert!(success, "Verification should pass");
    
    let device_info = device_info.expect("Device info should be present");
    assert_eq!(device_info.device_on, true, "Device should be on");
    assert_eq!(device_info.device_type, "02", "Device type should be '02'");
    assert_eq!(device_info.version, "00", "Version should be '00'");
    assert_eq!(device_info.user_type, "FF", "User type should be 'FF'");
       
}


#[test]
fn test_parse_device_response() {
   
    init_logger();

    info!("Testing parse_device_response");

    let received_data = "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
    
    // Parse the response
    let response = CommandGenerator::parse_device_response(received_data)
        .expect("Should successfully parse device response");

    // Verify main command data
    assert_eq!(response.main_data.device_mode, DeviceMode::try_from(6).unwrap(), "Current mode should be 6");
    assert_eq!(response.main_data.color, 9, "Text color should be 9");
    assert_eq!(response.main_data.text_size_x, 148, "Text size should be 148");
    assert_eq!(response.main_data.run_speed, 56, "Run speed should be 56");
    assert_eq!(response.main_data.text_distance, 165, "Text distance should be 165");

    // Verify settings data
    assert_eq!(response.settings.dmx_channel, 0, "Channel value (dmx_channel) should be 0");  // Channel starts at 1 (range 1-512)
    assert_eq!(response.settings.display_range, 48, "Display range (display_range) should be 48 (hex 0x30)");  // Display range from command
    assert_eq!(response.settings.red_beam, 100, "R value (red_beam) should be 100");  // Position 6, Red
    assert_eq!(response.settings.green_beam, 100, "G value (green_beam) should be 100");  // Position 7, Green
    assert_eq!(response.settings.blue_beam, 100, "B value (blue_beam) should be 100");  // Position 8, Blue
    assert_eq!(response.settings.xy, 0, "XY config should be 0");
    assert_eq!(response.settings.beams, 3, "Light mode should be 3");
    assert_eq!(response.settings.ttl_or_analog, 0, "Config should be 0");


    // Verify device info
    assert!(response.device_info.device_on, "Device should be on");
    assert_eq!(response.device_info.device_type, "02", "Device type should be '02'");
    assert_eq!(response.device_info.version, "00", "Version should be '00'");
    assert_eq!(response.device_info.user_type, "FF", "User type should be 'FF'");

}




#[test]
fn test_parse_device_info() {
    init_logger();

   let test1 =   "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let main_command = CommandGenerator::parse_device_info(&test1);
   let main_command = main_command.unwrap();
   info!("Parsed device info   : {:?}", main_command);

}



#[test]
fn test_parse_main_command() {

    init_logger();

   //let test1 = "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let test2 = "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C3060002BABA5454C100A800000000003700FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030011002300646464030000000000000004050607D0D1D2D38300B5190000000000002959005E003200FFD23250000000000000000000003200FF000050000000000000000000003200FF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D78049B92700000200E4E5E6E7";
   info!("Test command   : {:?}", test2);
   let main_command = CommandGenerator::parse_main_command(&test2);
   let main_command = main_command.unwrap();
   info!("Example main command   : {:?}", main_command);

   // Test packing and unpacking
   let example1 ="C0C1C2C3060002BABA5454C100A800000000003700FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7";
   //let example = "C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7";
   info!("Example main command   : {:?}", example1);
   let packed = CommandGenerator::pack_main_command(&main_command);
   let test_command = CommandGenerator::parse_main_command(&packed);
   info!("Parsed main command   : {:?}", test_command);
   info!("Packed main command   : {:?}", packed);
   assert_eq!(packed, example1, "Packed command should match example");
 

}


#[test]
fn test_parse_pis_command() {

    init_logger();

   let test1 =   "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let pis_command = CommandGenerator::parse_pis_command(&test1);
   let pis_command = pis_command.unwrap();
   info!("Parsed pis  command   : {:?}", pis_command);


}

#[test]
fn test_parse_playback_command() {

    init_logger();

   let test1 =   "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let prj_command = CommandGenerator::parse_playback_command(&test1);
   let prj_command = prj_command.unwrap();
   info!("Parsed prj  command   : {:?}", prj_command);


}

#[test]
fn test_parse_device_features() {
    init_logger();
   let test1 =   "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let features = CommandGenerator::parse_features(&test1);
   let features = features.unwrap();
   info!("Parsed device features   : {:?}", features);

}

#[test]
fn test_parse_settings_data() {

    init_logger();
   
   //const SETTINGS_CMD_HEADER: &str = "00010203";
   //const SETTINGS_CMD_FOOTER: &str = "000000000004050607";
   //let test =  SETTINGS_CMD_HEADER.to_string() + "0001003000646464030000" + SETTINGS_CMD_FOOTER;
   
   let test1 =   "E0E1E2E3B0B1B2B3FFB4B5B6B7C0C1C2C306000994943838A5007000000000512E80FFFFFFFFFFFFFFFF80000000000000000080FFFFFFFFFFFFFFFF80FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4C5C6C7000102030001003000646464030000000000000004050607D0D1D2D38100F52000000000000000000000003200FFD4D5D6D7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4D5D6D7887F4282FF000200E4E5E6E7";
   let settings1 = CommandGenerator::parse_settings_command(&test1);
   let settings1 = settings1.unwrap();
   info!("Parsed settings1   : {:?}", settings1);


    let test2 = "000102030001003707FFFFFF010000000000000004050607";

    let settings = CommandGenerator::parse_settings_command(test2);
    let settings = settings.unwrap();

    let test3 = CommandGenerator::get_setting_cmd(&settings);

    let expected_settings = DeviceSettings {
        dmx_channel: 0,
        xy: 7,
        beams: 1,
        ttl_or_analog: 0,
        proto: 1,
        display_range: 55,
        red_beam: 255,
        green_beam: 255,
        blue_beam: 255,
    };

    let test4 = CommandGenerator::get_setting_cmd(&expected_settings);

   
    info!("Example settings  : {:?}", expected_settings);
    info!("Example command   : {}", test4);
    info!("Parsed settings   : {:?}", settings);
    info!("Parse command     : {}", test2);
    info!("Generated command : {}", test3);
   

    assert_eq!(test2,test4,"Generated command should match original");
    assert_eq!(test2,test3,"Generated command should match original");

}

#[test]
fn test_prj_selected_bit_conversion() {
        // Create a ProjectItem with prj_selected = vec![255, 255, 255, 255]
        let item = Playback { playback_mode: 128, selected_plays: vec![255, 255, 255, 255] };

    // Unpack to bits
    let bits = CommandGenerator::unpack_project_item_bits(&item);
    // Should be 64 bits, each 255 is 8 ones then 8 zeros
    assert_eq!(bits.len(), 64, "Bit vector should have 64 elements");
    info!("bits: {:?}", bits);
    for chunk in bits.chunks(16) {
        let expected: Vec<u8> = vec![1; 8].into_iter().chain(vec![0; 8].into_iter()).collect();
        assert_eq!(chunk, expected.as_slice(), "Each chunk should be 8 ones then 8 zeros for 255");
    }

    // Pack back to prj_selected
    let packed = CommandGenerator::pack_bits_to_prj_selected(&bits);
    assert_eq!(packed, vec![255, 255, 255, 255], "Packed prj_selected should match original");
}

#[test]
fn test_pack_bits_to_prj_selected_50_selected() {
    // Create a bit vector with 50 selected buttons (first 50 bits set to 1, rest 14 bits set to 0)
    let mut bits = vec![1u8; 50];
    bits.extend(vec![0u8; 14]); // total 64 bits
    assert_eq!(bits.len(), 64, "Bit vector should have 64 elements");

    // Pack bits into prj_selected Vec<u8>
    let packed = CommandGenerator::pack_bits_to_prj_selected(&bits);
    info!("Packed prj_selected for 50 selected: {:?}", packed);
    // Print each packed value in hex for clarity
    for (i, val) in packed.iter().enumerate() {
        info!("packed[{}] = 0x{:04X}", i, val);
    }

    // Unpack back to bits and check first 50 are 1, rest are 0
    let unpacked = CommandGenerator::unpack_project_item_bits(&Playback { playback_mode: 128, selected_plays: packed.clone() });
    assert_eq!(unpacked.len(), 64, "Unpacked bit vector should have 64 elements");
    assert_eq!(&unpacked[..50], vec![1u8; 50].as_slice(), "First 50 bits should be 1");
    assert_eq!(&unpacked[50..], vec![0u8; 14].as_slice(), "Last 14 bits should be 0");
}