
use darkelf::draw::DrawUtils;
use darkelf::command::CommandGenerator;
use darkelf::model::EncodedCommandData;
use ttf_parser::Face;

struct PathPrinter;


#[test]
fn test_glyphs() {
    


    //let fontName = "Roboto-Bold.ttf";
    let fontName = "laser.regular.ttf";
    let ttf_bytes = std::fs::read(format!("assets/fonts/{}", fontName)).unwrap();
    let face = Face::from_slice(&ttf_bytes, 0).unwrap();


    let text_data = DrawUtils::get_text_lines(&face, "DARKELF", None, None);

    let simplified_shapes = DrawUtils::layout_and_simplify_shapes(&text_data, false, true, true);


    // Serialize text_data to JSON and write to file
    let json = serde_json::to_string_pretty(&simplified_shapes).unwrap();
    std::fs::write("darkelf_coordinates.json", json).unwrap();
    println!("Wrote text_data to darkelf_coordinates.json");


    //let (segment_points, grouped_segments, n, h, x_offset, group_point_counts, extra_floats) = DrawUtils::generate_segmented_layout_data(&simplified_shapes, 0.5, 0);
    //let segment_pointsJson = serde_json::to_string_pretty(&segment_points).unwrap();
    //std::fs::write("segment_points.json", segment_pointsJson).unwrap();
    //println!("Wrote text_data to segment_points.json");

    let  data: EncodedCommandData = CommandGenerator::encode_layout_to_command_data(
        &simplified_shapes,
        5.0,
    ).unwrap();

    let datapath = serde_json::to_string_pretty(&data).unwrap();
    std::fs::write("encodedcommanddata.json", datapath).unwrap();
    println!("Wrote text_data to encodedcommanddata.json");

   // let verify_cmd = "81e9804f01820c804f1181d1004f1181bb004f1181be00341081e9804f11819b804f0181c600341081c9004f1181b3004f118178804f11819b804f11819d801401819d802e1181f0802e1181f0801411819d801411813c00000080d800000080740000008010000000005400000000b8000000011c000000018000000001e4000000";
   let verify_cmd_b = "83ff804f0183b0804f1183ff004f1183ff804f1183b080380183e880381183e800381183b000381183b08038118342004f018358004f21839c804f218383804f21837180242183298024218317804f2182fe804f218342004f218333800d018367800d21834d0030218333800d2182d300000182ae000031826a804f31824c804f318290000031827400003182ea004f3182ea804f3182d3804f3182d3000031827400170182d300173182d300383182730038318274001731819a004f0181b8004f418221802c418221004f418238004f418238804f418221804f4181ec80114181b8804f41819a804f4181de000041819a004f418186804f0180e9804f5180e9803851816f803851816f00005180ff00005180ff001751816f001751816f00385180e900385180e9004f518186004f518186804f51803780380180be80386180be004f6180d5004f6180d5804f618037804f618037803861007b003801007b004f718023004f718023804f71800c804f71800c00007100640000710064001771800c001771800c003871007b00387100b7000000011b000000017f00000001e3000000024700000002ab000000030f000000037300000003d7000000";
   
    assert_eq!(verify_cmd_b, data.cmd);

    let cmd_text = CommandGenerator::get_xys_cmd(&simplified_shapes, 5.0);

    // Fine-grained protocol assertions
    // These indices are based on the expected command format and field lengths
    // Adjust indices if protocol changes

    //let char_width_hex = &cmd_text[138..158];
    //let char_point_hex = &cmd_text[168..188]; // 10 segments * 2 hex chars


    //assert_eq!(char_width_hex, "A8646464646464646464", "charWidthHex mismatch");
    //assert_eq!(char_point_hex, "11010101010101010101", "charPointHex mismatch");

    let verify_cmd_b = "A0A1A2A300591083FF804F0183B0804F1183FF004F1183FF804F1183B080380183E880381183E800381183B000381183B08038118342004F018358004F21839C804F218383804F21837180242183298024218317804F2182FE804F218342004F218333800D018367800D21834D0030218333800D2182D300000182AE000031826A804F31824C804F318290000031827400003182EA004F3182EA804F3182D3804F3182D3000031827400170182D300173182D300383182730038318274001731819A004F0181B8004F418221802C418221004F418238004F418238804F418221804F4181EC80114181B8804F41819A804F4181DE000041819A004F418186804F0180E9804F5180E9803851816F803851816F00005180FF00005180FF001751816F001751816F00385180E900385180E9004F518186004F518186804F51803780380180BE80386180BE004F6180D5004F6180D5804F618037804F618037803861007B003801007B004F718023004F718023804F71800C804F71800C00007100640000710064001771800C001771800C003871007B00387100B7000000011B000000017F00000001E3000000024700000002AB000000030F000000037300000003D7000000011063B2B2B2B2B2B2646464646464646464090D0F0C0D070B01010101010101010100000000000001020303040405050607010203040506060606070708080909090005A4A5A6A7";
   

  //  let verify_text = "A0A1A2A3001A0A81E9804F01820C804F1181D1004F1181BB004F1181BE00341081E9804F11819B804F0181C600341081C9004F1181B3004F118178804F11819B804F11819D801401819D802E1181F0802E1181F0801411819D801411813C00000080D800000080740000008010000000005400000000B8000000011C000000018000000001E4000000010AA86464646464646464641101010101010101010100000000000000000001010203040506070809090005A4A5A6A7";

    //std::fs::write("rust_output.txt", &cmd_text).unwrap();
    //std::fs::write("js_output.txt", &verify_text).unwrap();

    assert_eq!(cmd_text, verify_cmd_b, "cmd_text does not match verify_text");
    //println!("Wrote text_data to darkelf_coordinates.json");
}