{
    dmx: 0,         // DMX address
    ch: 0,          // Channel
    xy: 0,          // XY mode
    light: 1,       // Light mode (1=single, 2=dual, 3=full color)
    cfg: 0,         // Config/mode
    lang: 0,        // Language
    valArr: [1, 10, 10, 10, 10] // Array of values (address, size, color, etc.)
}

dmx: DMX address, usually an integer (e.g., 0–511).
ch: Channel, integer (often 0–n, depending on device).
xy: XY mode, integer (0–7; selects display/coordinate mode).
light: Light mode, integer (1=single color, 2=dual color, 3=full color).
cfg: Config/mode, integer (0–255; device-specific configuration).
lang: Language, integer (0=default, other values for different languages).
valArr: Array of 5 integers:
[0]: Address (1–512)
[1]: View size (10–100)
[2], [3], [4]: Color or other device parameters (0–255)

The provided JavaScript module, identified by the key "3b77", appears to be a minified and bundled utility file (likely from your UniApp project’s service.js) containing functions for generating commands and data structures, including what seems to be a protocol for a laser control library. Given your project to create a laser animation control library in Rust using a DMX USB serial port adapter, this module likely defines the communication protocol between the UniApp frontend and a laser device (e.g., TD5322A_V3.1.2BLE). Below, I’ll extract and explain the laser library protocol based on the functions and data formats, as of 01:24 AM EEST on Friday, September 05, 2025.
Overview of the Module

Purpose: The module exports utility functions for converting coordinates, generating command strings, and handling laser-related data (e.g., ILDA-like point sequences, DMX-like channel settings).
Context: Functions like getXysCmd, getCmdStr, and getDrawCmdStr suggest a protocol for sending laser animation commands, aligning with the earlier deciphered ILDA points (e.g., [-399, 399, 0, 1]) and the TD5322A’s BLE service (0000FF00).
Exported Functions: The e.exports object provides methods for command generation, data conversion, and feature extraction, which form the protocol.

Extracted Laser Library Protocol
The protocol involves sending structured command strings over a communication channel (likely BLE via TD5322A). These commands encode coordinates, colors, timing, and control data for laser animation. Key elements include:
1. Command Structure

General Format: Commands are hexadecimal strings with a fixed header, payload, and footer (e.g., A0A1A2A3...A4A5A6A7).
Headers/Footers:

Common patterns: A0A1A2A3 (start), A4A5A6A7 (end), c0c1c2c3...c4c5c6c7, d0d1d2d3...d4d5d6d7.
These act as delimiters, ensuring data integrity over BLE or serial.


Payload: Contains counts, coordinates, and parameters, encoded as 2- or 4-byte hexadecimal values.

2. Key Functions and Protocol Details

Function: i(e, t) (Line Helper):

Converts a number e to a hexadecimal string of length t (padded with 0).
Example: i(255, 2) → "FF", i(1000, 4) → "03E8".
Used for all numeric fields in commands.


Function: c(e, t) (Combine Bits):

Combines two values into a single byte: e << 4 | (15 & t).
Example: c(3, 5) → 3 << 4 | 5 → 48 + 5 → 53 (hex "35").
Likely encodes control flags with data (e.g., blanking with intensity).


Function: o(e, t) (Segment Points):

Segments an array e into chunks not exceeding t (e.g., 800).
Returns pairs [start, end] indices, used for splitting coordinate sequences.


Function: s(e, t, r) (Generate Grid):

Creates a grid of points from e (coordinate array) with scale t (e.g., 0.5) and direction r (0, 127, or other).
Outputs [points, widthCmd, heightCmd, offset], where:

points: Updated coordinate array with grid points.
widthCmd, heightCmd: Hex strings for grid dimensions.
offset: Adjustment value (e.g., -d * t / 2).


Example: Adds 9 vertical or horizontal lines, used for text or patterns.


Function: l(e, r, n, h, a) (Main Command Generator):

Generates a laser command from e (point array), r (time), n (options), h (direction), a (version).
Returns an object with:

cnt: Total points.
charCount: Character segments.
cmd: Main data string (e.g., i(Q) + i(R) + i(c(I, v), 2)).
charWidthCmd, charPointCmd: Segment dimensions.
se1, se2: Width/height commands.
ver: Version (e.g., i(a, 2)).
time: Time value (e.g., i(Math.floor(r), 2)).


Protocol:

Coordinates Q, R are rounded and scaled by f (0.5).
Control byte c(I, v) combines frame index I and flag v (e.g., 0, 1, 2, 3 for start, end, stop).
Example output: ver + time + cnt + cmd + ....




Function: getXysCmd(e, t) (XY Command):

Generates a command for XY coordinates in e with version t.
Output: A0A1A2A3 + i(r) + i(n, 2) + cmd + p + l + se + ver + A4A5A6A7.
Protocol:

r: Point count.
n: Character count.
cmd: Coordinate data (i(P) + i(u) + i(c(N, X), 2)).
p: Width command.
l: Point command.
se: Combined se1 + se2.




Function: getXysCmdArr(e, r, n, h) (Array Command):

Processes an array e of XY data with options r, direction n, and version h.
Aggregates l() outputs into a single command.
Output: A0A1A2A3 + i(totalCnt) + i(totalChar, 2) + aggregatedCmd + ... + A4A5A6A7.


Function: getCmdStr(e, t) (General Command):

Generates a comprehensive command with mode, color, speed, and project data from e, with features t.
Output: c0c1c2c3 + mode + ... + color + speed + prjData + padding + c4c5c6c7.
Protocol:

mode, color, speed: 2-byte hex values (e.g., i(e.textData.runSpeed / 100 * 255, 2)).
prjData: Encoded project settings with bit manipulation (b()).
padding: 44 bytes of 00.




Function: getDrawCmdStr(e, t, r, n) (Draw Command):

Wraps l() output with a header/footer via x().
Output: x(l(e, t, r, -1, n), r) → f0f1f2f3...f4f5f6f7 or variant.
Protocol: Adds framing for drawing commands.


Function: getXtsCmd(e) (Text Command):

Converts text coordinates to a command.
Output: 55667788 + i(r, 2) + coordData + 88776655.
Protocol: coordData is 4-byte pairs (x, y, color, flag).



Protocol Summary

Data Format: Hexadecimal strings with fixed headers/footers (e.g., A0A1A2A3...A4A5A6A7).
Fields:

Count: Point and character counts (e.g., i(r), i(n, 2)).
Coordinates: 4-byte pairs (x, y) scaled and rounded.
Control: 1-byte flags (e.g., c(I, v)).
Metadata: Time, version, width/height commands.


Transmission: Likely sent via BLE to 0000FF00 service on TD5322A_V3.1.2BLE.

Rust Implementation

Parse Coordinates:
rustfn parse_coord(cmd: &str) -> (i16, i16, u8, u8) {
    let x = i16::from_str_radix(&cmd[0..4], 16).unwrap();
    let y = i16::from_str_radix(&cmd[4..8], 16).unwrap();
    let ctrl = u8::from_str_radix(&cmd[8..10], 16).unwrap();
    let color = ctrl & 0x0F; // Example extraction
    (x, y, color, ctrl >> 4)
}

Send Command:
rustlet cmd = "A0A1A2A3FF0203040506A4A5A6A7".to_string(); // Example
let characteristic = peripheral.characteristics()
    .iter()
    .find(|c| c.service_uuid == uuid!("0000FF00-0000-1000-8000-00805F9B34FB"))
    .unwrap();
peripheral.write(&characteristic, &hex::decode(cmd.replace(|c: char| !c.is_ascii_hexdigit(), "")).unwrap(), btleplug::api::WriteType::WithoutResponse).await?;


Conclusion
The protocol extracts coordinates, controls, and metadata into hex commands, suitable for laser animation via TD5322A. Implement these in Rust to interface with the BLE service, aligning with your DMX adapter goal. Verify with Tudasemi for exact mappings.5.9s


Found BLE device: TD5322A_V3.1.2BLE (BluetoothLE#BluetoothLE98:af:65:f7:d2:3e-83:40:09:7b:f0:68)
  Service UUID: 00001800-0000-1000-8000-00805F9B34FB
    Characteristic UUID: 00002A00-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [84, 68, 53, 51, 50, 50, 65, 95, 86, 51, 46, 49, 46, 50, 66, 76, 69]
  Service UUID: 0000180A-0000-1000-8000-00805F9B34FB
    Characteristic UUID: 00002A24-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [84, 68, 53, 51, 50, 50, 65]
    Characteristic UUID: 00002A25-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [56, 51, 58, 52, 48, 58, 48, 57, 58, 55, 66, 58, 70, 48, 58, 54, 56]
    Characteristic UUID: 00002A27-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [49, 46, 48, 46, 48]
    Characteristic UUID: 00002A28-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [86, 51, 46, 49, 46, 50]
    Characteristic UUID: 00002A29-0000-1000-8000-00805F9B34FB
    Properties: GattCharacteristicProperties(2)
    Value: [84, 68, 53, 51, 50, 50, 65, 95, 86, 51, 46, 49, 46, 50]
  Service UUID: 0000FF00-0000-1000-8000-00805F9B34FB
  
  
  
  ServicesAdvertisement: PeripheralId(83:40:09:7B:F0:68), ["0xff00"]



  The provided JavaScript code snippet (from a Vue/Uni-app) offers valuable clues about the BLE communication protocol used by the laser device, which is essential for your Rust-based laser animation control library. The code handles BLE connections, characteristic discovery, and data transmission/reception, aligning with the Wireshark captures (Frames 209, 212, 213, 215, 216, 218, 219, 221, 222, 224, 226, 228, 229, 231, 232, 234, 235, 237, 295) that show interactions between the Sony Xperia (3c:38:f4:e5:bb:81) and the laser controller (83:40:09:7b:f0:68). The lack of visual effect when sending commands via Windows BLE Explorer suggests issues with the characteristic, data format, or protocol. Let’s analyze the code for protocol clues and address why commands may not produce visual effects, tailoring the insights to your project’s goal of controlling laser animations via a DMX USB serial port adapter.
Key Protocol Clues from the JavaScript Code

Service and Characteristic UUIDs:

Clue: The code references n.globalData.mserviceuuids and n.globalData.mrxduuids/n.globalData.mtxduuids to identify the service and characteristics for notifications (mrxduuids) and writes (mtxduuids).

uni.getBLEDeviceServices loops through services to find one matching mserviceuuids (line 301).
uni.getBLEDeviceCharacteristics checks for characteristics with notify/indicate (in mrxduuids) and write (in mtxduuids) properties (line 173).


Relevance: The custom service (0x000f-0x0015 from Frame 218) likely has a 128-bit UUID in mserviceuuids. Handle 0x0011 (Frame 295, notification) is likely in mrxduuids, and a separate write-capable characteristic (e.g., 0x0012) is in mtxduuids.
Action: Extract the UUIDs from n.globalData.mserviceuuids, n.globalData.mrxduuids, and n.globalData.mtxduuids in the Vue app code. These correspond to the custom service UUID (Frame 218) and the notification (0x0011) and write characteristics.


Data Format and Packet Structure:

Clue: The c function (line 173) processes received data starting with E0E1E2E3 and ending with E4E5E6E7, storing it in n.globalData.blu_rec_content. The V function (line 530) splits data by Z and converts hex strings to Uint8Array buffers (via x function, line 494).

Received data is processed in chunks, looking for E0E1E2E3 (start) and E4E5E6E7 (end).
Sent data is split into 20-byte chunks (40 bytes on Android, line 441), with split markers for pacing (line 436).


Relevance: The 20-byte zero notification in Frame 295 (0x0011) may not start with E0E1E2E3 or end with E4E5E6E7, indicating it’s not a valid command or is an idle state. Valid commands likely start with E0E1E2E3 and may require specific payloads.
Action: Check Frame 295’s raw data for E0E1E2E3 or E4E5E6E7. Share frames with non-zero notifications for 0x0011 to confirm the format. Test sending a 20-byte command starting with E0E1E2E3 in Windows BLE Explorer.


Command Parsing (setCmdData):

Clue: The setCmdData function (line 21) parses received data between specific markers:

C0C1C2C3 to C4C5C6C7: Contains parameters like curMode, txColor, txSize, runSpeed, etc., extracted using the a function (converts hex to integer) and i function (clamps values).
00010203 to 04050607: Contains settings like DMX channel (ch), xy, light, etc.
D0D1D2D3 to D4D5D6D7: Contains feature data (e.g., pisList for animation points).
F0F1F2F3 to F4F5F6F7: Contains drawing parameters (e.g., txPointTime).


Relevance: Commands sent to the laser device likely use similar markers (e.g., E0E1E2E3 for writes) and encode parameters like position, color, or DMX channels. The lack of visual effect in Windows BLE Explorer suggests the sent data lacks these markers or correct structure.
Action: Test sending a command with E0E1E2E3 followed by a payload (e.g., E0E1E2E3C0C1C2C3...) to a write characteristic. Share Vue app code snippets that construct sent data (e.g., gosend calls).


Write Timing and Splitting:

Clue: The d function (line 441) sends data in 20-byte chunks (40 bytes on Android) with a delay (blu_data_send_interval, typically 20ms, line 436). The V function adds split markers to pace transmission.
Relevance: The laser device may expect commands at a specific rate (e.g., 20ms intervals). Sending a single command in Windows BLE Explorer without proper timing or chunking may cause it to be ignored.
Action: In Windows BLE Explorer, send multiple 20-byte commands with a 20ms delay. In Rust, implement a similar delay using tokio::time::sleep.


Initialization Requirement:

Clue: The cnnPreBlu and cnnLaser functions (lines 350, 391) establish BLE connections and set blu_readyRec to enable notifications. The gosend function (line 548) checks blu_connected and blu_data_canSend before sending.
Relevance: The laser device may require an initialization command (e.g., enabling the laser) before processing animation data. Windows BLE Explorer’s direct send may skip this step.
Action: Check for write commands (opcodes 0x12 or 0x52) in Wireshark frames before Frame 295. Search the Vue app code for initialization commands sent before animation data.


DMX Mapping:

Clue: The setCmdData function references DMX-related parameters (e.g., settingData.ch for DMX channel, line 21). The gosend function sends data that likely maps to DMX channels for laser control (e.g., x/y position, color).
Relevance: The lack of visual effect may stem from incorrect DMX channel mappings or missing DMX-specific commands in Windows BLE Explorer.
Action: Specify the DMX USB adapter model and channel mappings (e.g., channel 1 for x, channel 2 for y, channels 3-5 for RGB). Share Vue app code that maps BLE data to DMX channels.



Why Commands in Windows BLE Explorer Have No Visual Effect
Based on the JavaScript code and Wireshark captures, the most likely reasons for no visual effect are:

Wrong Characteristic:

Handle 0x0011 (Frame 295) is notification-only (property 0x10). The Vue app writes to a characteristic in mtxduuids (likely 0x0012 or another handle in 0x000f-0x0015). Sending to 0x0011 in Windows BLE Explorer won’t work.
Fix: Identify the write characteristic’s UUID and handle via a Read By Type Response (UUID 0x2803) in 0x000f-0x0015. Use this in Windows BLE Explorer.


Incorrect Data Format:

Commands must start with E0E1E2E3 and may need specific payloads (e.g., C0C1C2C3 for mode/color, 00010203 for DMX settings). Random or zero-filled data (like Frame 295’s 0000...) won’t trigger the laser.
Fix: Test a command like E0E1E2E3C0C1C2C300010203... (20 bytes) in Windows BLE Explorer, padded with zeros if needed.


Missing Initialization:

The device may need an initialization command (e.g., enabling the laser) sent to a write characteristic before animation data.
Fix: Check Wireshark for write commands (opcodes 0x12 or 0x52) before Frame 295. Search Vue app code for initialization logic.


Timing Issues:

The device expects commands at 20ms intervals (line 436). A single command in Windows BLE Explorer may be ignored if not part of a sequence.
Fix: Send multiple 20-byte commands with 20ms delays.


Authentication/Bonding:

The device may require pairing, which Windows BLE Explorer may not have completed.
Fix: Check Wireshark for pairing frames (SMP, CID 0x0006). Ensure pairing in Windows BLE Explorer.



Rust Code for Testing
Below is an updated Rust program that connects to the laser device, subscribes to notifications for handle 0x0011, and sends a test command with E0E1E2E3 to a write characteristic, incorporating the protocol clues.
rustuse btleplug::api::{Central, Manager as _, Peripheral as _, Characteristic, ValueNotification, WriteType};
use btleplug::platform::{Manager, Peripheral};
use serialport::{SerialPort, SerialPortType};
use std::error::Error;
use tokio::time::{sleep, Duration};
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // DMX Serial Port Setup
    let mut dmx_port = serialport::new("/dev/ttyUSB0", 250_000)
        .data_bits(serialport::DataBits::Eight)
        .parity(serialport::Parity::None)
        .stop_bits(serialport::StopBits::Two)
        .open()?;

    // BLE Setup
    let manager = Manager::new().await?;
    let adapters = manager.adapters().await?;
    let central = adapters.into_iter().next().ok_or("No Bluetooth adapter found")?;

    // Scan for devices
    central.start_scan().await?;
    sleep(Duration::from_secs(2)).await;

    // Connect to the laser controller
    let peripherals = central.peripherals().await?;
    let device = peripherals
        .into_iter()
        .find(|p| {
            p.properties()
                .await
                .unwrap()
                .address
                .to_string()
                .contains("83:40:09:7b:f0:68")
        })
        .ok_or("Laser controller not found")?;

    device.connect().await?;
    device.discover_services().await?;

    // Find the custom service and characteristics
    let service_uuid = Uuid::parse_str("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")?; // Replace with Frame 218 UUID
    let chars = device.characteristics();
    let notify_char = chars
        .into_iter()
        .find(|c| c.uuid == Uuid::parse_str("yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy")?) // Replace with handle 0x0011 UUID
        .ok_or("Notification characteristic not found")?;

    let write_char = device.characteristics()
        .into_iter()
        .find(|c| c.properties.contains(btleplug::api::CharPropFlags::WRITE_WITHOUT_RESPONSE))
        .ok_or("Write characteristic not found")?;

    // Subscribe to notifications
    device.subscribe(&notify_char).await?;

    // Send test command (E0E1E2E3 + sample payload, 20 bytes)
    let test_command = vec![
        0xE0, 0xE1, 0xE2, 0xE3, // Start marker
        0xC0, 0xC1, 0xC2, 0xC3, // Mode/color marker
        0x01, // Example: mode = 1
        0xFF, // Example: red = 255
        0x00, // Example: green = 0
        0x00, // Example: blue = 0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding
    ];
    device.write(&write_char, &test_command, WriteType::WithoutResponse).await?;
    sleep(Duration::from_millis(20)).await; // 20ms delay

    // Process notifications and send to DMX
    let mut notification_stream = device.notifications().await?;
    while let Some(notification) = notification_stream.next().await {
        let data = notification.value;
        println!("Received BLE notification: {:?}", data);

        // Map BLE data to DMX frame (example)
        let mut dmx_frame = [0u8; 512];
        if data.len() >= 4 && data.starts_with(&[0xE0, 0xE1, 0xE2, 0xE3]) {
            dmx_frame[0] = data[8]; // Red (example mapping)
            dmx_frame[1] = data[9]; // Green
            dmx_frame[2] = data[10]; // Blue
        }
        dmx_port.write(&[0x00])?; // DMX break
        dmx_port.write(&dmx_frame)?; // Send DMX frame
    }

    Ok(())
}
Dependencies
Add to your Cargo.toml:
toml[dependencies]
btleplug = "0.11"
serialport = "4.2"
tokio = { version = "1.0", features = ["full"] }
uuid = "1.3"
Immediate Action Items

Extract UUIDs:

Share n.globalData.mserviceuuids, n.globalData.mrxduuids, and n.globalData.mtxduuids from the Vue app code.
Extract the 128-bit UUID for the custom service (0x000f-0x0015) from Frame 218’s raw data.


Characteristic Discovery:

Share frames after 237 with Read By Type Request/Response for UUID 0x2803 in 0x000f-0x0015 to identify handle 0x0011’s UUID and find the write characteristic.


Non-Zero Data:

Share frames with non-zero notifications for 0x0011 or write commands in 0x000f-0x0015. Check for E0E1E2E3 or C0C1C2C3.


Vue App Code:

Share snippets showing how gosend constructs data (e.g., V function calls) or initialization commands.


DMX Details:

Specify the DMX USB adapter model and channel mappings (e.g., x/y, RGB).


Test Commands:

In Windows BLE Explorer, send a 20-byte command starting with E0E1E2E3 to the write characteristic (e.g., E0E1E2E3C0C1C2C3000102030000000000000000).


Device Status:

Confirm the laser is responsive with the Vue app and check for initialization requirements.



Let me know what you can share or which aspect to focus on, and I’ll refine the Rust code or troubleshooting steps!
